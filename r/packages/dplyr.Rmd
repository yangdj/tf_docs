## dplyr

install following packages before using:

* `tidyverse`: the whole tidyverse
* `dplyr`: just dplyr
* `dbplyr`: work with remote database tables

### operations

* `%>%`: data pipe

* `!! vars`: tells `dplyr` to bypass the data frame and to directly look in the context
    * usage
        * `vars <- c("year", "month"); select(flights, !! vars)`
        
* `mutate()`: adds new variable that are functions of existing variables

* `transmute()`: similar to `mutate()`, but just keep the new variables

* `select()`: picks variables based on their names, drops variables not mentioned

    * usage
        * `select(flights, year, month, day)`
        * `select(flights, year:day)`
        * `select(flights, -(year:day))`
        * `select(flights, identity(year))`
    * inside functions
        * `starts_with()`
        * `ends_with()`
        * `matches()`
        * `contains()`
        * `everything()`
        * `one_of()`
        * `num_range()`
        
* `rename()`: keeps all variables, rename specified variables

* `filter()`: picks cases based on their values

* `summarise()`: reduces multiple values down to a single summary
    * inside functions
        * `n()`
        * `n_distinct(x)`
        * `first(x)`
        * `last(x)`
        * `nth(x, n)`
        * `mean()`
        * `sum()`
        * `min()`
        * `max()`
        * `sd()`
        * `median()`
        * `IQR()`
        
* `arrange()`: reorder rows
    * inside functions
        * `desc()`: in descending order
        
* `group_by()`: performs "by group"

* `group_by_at()`: group by a selection of variables
    * usage
        * `group_by_at(df, vars(year:day))`
        
* `sample_n()`: takes a certain number of random samples

* `sample_frac()`: takes a certain fraction of random samples

### wrapper for summarise

* `tally()`
* `count()`
* `add_tally()`
* `add_count()`

### window functions

window functions are used in conjuction with `mutate()` and `filter()`.

* rank

    * `row_number()`
    * `min_rank()`
    * `dense_rank()`
    * `ntile()`
    * `percent_rank()`
    * `cume_dist()`

* offset
    
    * `lead()`
    * `lag()`

* cumulative aggregates

    * `cumsum()`
    * `cummin()`
    * `cummax()`
    * `cummean()`
    * `cumall()`
    * `cumany()`
    * `order_by()`

### join tables

#### mutate joins:

* `inner_join()`
* `left_join()`
* `right_join()`
* `full_join()`

#### filtering joins:

* `semi_join()`
* `anti_join()`

#### set operations

* `intersect()`
* `union()`
* `setdiff()`

#### coercion rules

* Factors with different levels are coerced to character with a warning
* Factors with the same levels in a different order are coerced to character with a warning
* Factors are preserved only if the levels match exactly
* A factor and a character are coerced to character with a warning
* Otherwise logicals will be silently upcast to integer, and integer to numeric, but coercing to character will raise an error
