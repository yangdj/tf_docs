# Scala

## SBT

1. References
    1. [scaladex](https://index.scala-lang.org/)
    2. [sbt](https://www.scala-sbt.org/index.html)
    3. [sbt-intro](https://zhuanlan.zhihu.com/p/82727108)
2. Install
    
    ```sh
    SBT_VERSION=1.5.4
    wget https://github.com/sbt/sbt/releases/download/v${SBT_VERSION}/sbt-${SBT_VERSION}.tgz
    ```
3. Envs

    ```sh
    export SBT_HOME=...
    export PATH=${SBT_HOME}/bin:${PATH}
    ```
4. Configurations
    1. `~/.sbt/repositories`

        ```ini
        [repositories]
        local
        huaweicloud-maven: https://repo.huaweicloud.com/repository/maven/
        maven-central: https://repo1.maven.org/maven2/
        sbt-plugin-repo: https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_ [sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
        ```
    2. Settings
        1. Path
            1. windows: `${SBT_HOME}/conf/sbtconfig.txt` 
            2. Linux: `${SBT_HOME}/conf/sbtopts`
        2. Contents
            1. `-XX:MaxPermSize=256m`: `Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0`
            2. `-Dsbt.override.build.repos=true`: use global repo
5. File Structure
    1. `project_name/`
        1. `build.sbt`
            1. `name := "hello-world"`
            2. `version := "1.0"`
            3. `scalaVersion := "2.13.1"`
            4. `organization := "ch.epfl.scala"`
            5. `scalacOptions ++= Seq("-unchecked", "-deprecation")`
            6. `libraryDependencies += "org.typelevel" %% "cats-core" % "2.0.0"`: mananged jar dependencies
                1. format: `groupID % artifactID % revision % configuration`
                    1. `%%` instead of `%` after groupID will add scala version to the artifactID name
                    2. `% configuration`
                        1. `test`: just for sbt `test` command , not for `compile`, useful for test dependencies package
                        2. `provided`: exclude the jars when packaging
                2. stored path
                    1. windows: `%LOCALAPPDATA%\Coursier\Cache\v1`
                    2. Linux: `~/.cache/coursier/v1; ~/.ivy2/cache`
                    3. Mac: `~/Library/Caches/Coursier/v1`
            7. `resolvers += <name> at <location>`: specify additinal dependencies download path
                1. `resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"`
        2. `project/`
            1. `build.properties`
                1. `sbt.version=1.5.4`
                    1.  `intellij sbt: Extracting structure failed`: make sure `sbt.version` is correct
        3. `scr/`
            1. `main/`
                1. `scala/`
                2. `resources/`
            2. `test/`
                1. `scala/`
                2. `resources/`
        4. `target/`: build output, included in `.gitignore`
        5. `lib/`: unmanaged jar dependencies which automatically added to `classpath` compared to mananged dependencies
            1. `unmanagedBase := baseDirectory.value / "custom_lib"`: specify customized path
                1. `baseDirectory.value`: root directory
                2. `custom_lib`: customized path, `[default: lib]`
6. Commands
    1. `sbtVersion`
    2. `show overrideBuildResolvers`: `true` when `-Dsbt.override.build.repos=true`
    3. `show fullResolvers`: show `sbtconfig.txt` config
    4. `show compile:dependencyClasspath`
    5. `show test:dependencyClasspath`
    6. `help <command>`
    7. `reload`: reload build files, `build.sbt`, `project/{*.scala, *.sbt}`
    8. `clean`: clear output under `target/`
    9. `update`: download dependencies manually, used by `compile`, so always no need to execute it
    10. `compile`: files in `src/main/{scala, java}`
    11. `test`: compile and run test file
    12. `console`: enter scala shell with compiled environment, `:quit` exits console
    13. `run [<arguments>...]`: run with arguments, may need select main class interactively
    14. `runMain <class> [<arguments>...]`: run specified class
    15. `package`: generate a jar file from `scr/main/resources` and `scr/main/{scala,java}`,  need `name` and `version` in the file `build.sbt`
    16. `assembly`
        1. `project_name/project/plugins.sbt`: `addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "1.0.0")`
        2. `project_name/build.sbt`: create this file if not exists

            ```scala
            //build.sbt
            import AssemblyKeys._ // put this at the top of the file

            assemblySettings
            ```
    17. `~<command>`: run the command automatically when files update, `~run`. `Enter` key will cancel it

## JVM Language

1. References
    1. [shapeless-guide](https://books.underscore.io/shapeless-guide/shapeless-guide.html)
1. Command
    1. Common
        1. `jar`
            1. `jar cvf helloworld.jar -C classes/ .`: package classes into helloworld.jar under the current directory
            2. `jar tvf helloworld.jar`
    2. Java
        1. `java -cp helloworld.jar HelloWorld`
    3. Scala
        1. `scalac`
            1. `scalac helloworld.scala`: compiles scala source
            2. `scalac -d classes helloworld.scala`: compiles scala source, and stores in specified folder
        2. `fsc`: fast scala compiler
            1. `fsc helloworld.scala`
            2. `fsc -shutdown`: shutdown daemon process
        3. `scala`
            1. `scala helloworld.scala`: runs scala script
            2. `scala helloworld`: runs compiled scala file
            3. `scala helloworld.jar`
            4. `scala -cp helloworld.jar Hello`: runs class Hello in jar file
2. Basic
    1. Java
        1. Variables
            1. Naming
                1. Rules
                    1. case sensitive
                    2. no length limit, sequence of Unicode letters and digits
                    3. begin with a letter (convention) or `_` or `$` but `_` and `$` not encouraged
                    4. subsequent characters may be letters, digits, dollar signs or underscore characters
                2. Styles
                    1. use camelCase
                    2. constant value capitalizes every letter and separates subsequent workds with underscore
            2. Primitive Data Types
                1. Numeric
                    1. Common
                        1. Since Java SE 7, any number of underscore character `_` can appear anywhere between digits in a numerical literals
                            1. `long creditCardNumber = 1234_5678_9012_3456L;`
                            2. `long hexBytes = 0xFF_EC_DE_5E;`
                            3. `long bytes = 0b11010010_01101001_10010100_10010010;`
                            4. `float pi =  3.14_15F;`
                    2. Integer
                        1. common
                            1. default literal type `int` unless ends with `l` or `L`
                            2. decimal: base 10, `26`
                            3. hexadecimal base 16, `0x1a`
                            4. binary: base 2, `0b11010`
                        2. `byte`
                            1. field default `0`
                            2. 8-bit signed two's complement integer
                            3. range `[-2^7, 2^7 -1]`
                        3. `short`
                            1. field default `0`
                            2. 16-bit signed two's complement integer
                            3. range `[-2^-15, 2^15 - 1]`
                        4. `int`
                            1. field default `0`
                            2. 32-bit signed two's complement integer
                            3. range `[-2^-31, 2^31 - 1]`
                        5. `long`
                            1. field default `0L`
                            2. 64-bit signed two's complement integer
                            3. range `[-2^-63, 2^63 - 1]`
                    3. Float
                        1. Common
                            1. default literal type `double` unless ends with `f` or `F`
                            2. double value can optionally end with `d` or `D`
                            3. decimal notation: `123.4`, `123.4f`
                            4. scientific notation: `1.234e+2`
                        2. `float`
                            1. field default `0.0f`
                            2. a single-precision 32-bit IEEE 754 floating point
                        3. `double`
                            1. field default `0.0d`
                            2. a double-precision 64-bit IEEE 754 floating point
                2. Others
                    1. `boolean`
                        1. field default `false`
                        2. value `{true, false}`
                    2. `char`
                        1. field default `\u0000`
                        2. 16-bit Unicode character
                        3. range `[\u0000, \uffff] ([0, 2^16 - 1])`
                        4. use single quotes
                        5. escape characters 
                            1. `\b`
                            2. `\t`
                            3. `\n`
                            4. `\f`
                            5. `\r`
                            6. `\"`
                            7. `\'`
                            8. `\\`
            3. Array: hold a fix number of values of a single type
                1. the length is established when created. after creation, the length is fixed
                2. element index begins with 0
                3. declaration
                    1. `int[] anArray`
                    2. `int anArray[]`: discouraged
                5. creation: `anArray = new int[10]`
                6. initialization: `anArray[0] = 100`
                7. access: `anArray[0]`
                8. creation and initialization: `int[] anArray = {100, 200, ..., 1000}`, length is determined by element number in the brace separated by commas
                9. multidimensional array
                    1. use multiple brackets: `int[][] counts`
                    2. each element is an array
                    3. rows can vary in length: `String[][] names = {{"Mr. ", "Mrs. ", "Ms. "}, {"Smith", "Jones"}}`
                10. members
                    1. `.length`
3. Class and Objects
    1. Java
        1. Class
            1.  Modifier
                1. top level
                    1. `public`: visible to all classes everywhere
                    2. no modifier: package-private, visible only within its own package
                2. Member level
                    1. `public`: same as top level
                    2. no modifier: package-private, same as top level
                    3. `private`: visible to its own class
                    4. `protected`: visible within ist own package (package-private) and subclass of its class in another package
                3. Member Variables
                    1. `static`: see *Class Variables*
                    2. `final`: value can not be changed
            2. Member
                1. Variables
                    1. Instance Variables: fields, non-static fields, unique to each instance of class
                        1. uninitialized default value
                            1. primitive: see primitive data types
                            2. objects: `null`
                    2. Class Variables: static fields, declared with `static` modifier, only one copy of this variable
                2. Methods
                    1. Parameters
                    2. Local Variables
                        1. compiler never assigns a default value to an uninitialized local variable
                        2. access uninitialized local variable results in compile-time error
        2. Object
            1. `null`
                1. can be assigned to any variable, except primitive types
                2. often used in program as a marker to indicate some object is unavailable
            2. `.class`: refer to object's class
4. Data Structure
    1. Architecture
        1. Relations
            1. `scala.Any`
                1. `scala.AnyVal`
                    1. `scala.Byte`
                    2. `scala.Short`
                    3. `scala.Int`
                    4. `scala.Long`
                    5. `scala.Float`
                    6. `scala.Double`
                    7. `scala.Char`
                    8. `scala.Boolean`
                    9. `scala.Unit`
                    10. ...
                2. `scala.AnyRef`
                    1. `scala.lang.String`
                    2. `scala.iterable`
                        1. `scala.Seq`
                            1. `scala.List`
                    3. `scala.Null`: subclass of all `scala.AnyRef` class
                3. `scala.Nothing`: subclass of all `scala.AnyRef` and `scala.AnyVal`
        2. Types
            1. immutable
                1. `java.lang.String`
                2. `[scala.]List(1, 2, 3)`
                3. `Tuple: (99, "buff")`: contain fixed-length and different types of elements, length up to 22 Tuple22
                4. `[scala.collection.immutable.]Set("Abuout", "Before")`
                5. `[scala.collection.immutable.]HashSet("Abuout", "Before")`
                6. `[scala.collection.immutable.]Map("A" -> "Abuout", "B" -> "Before")`
                7. `[scala.collection.immutable.]HashaMap("A" -> "Abuout", "B" -> "Before")`
                8. `[scala.collection.immutable.]Range`
            2. mutable
                1. `Array`
                2. `scala.collection.mutable.ListBuffer`
                3. `scala.collection.mutable.Set("About", "Before")`
                4. `scala.collection.mutable.HashSet("About", "Before")`
                5. `scala.collection.mutable.Map("A" -> "Abuout", "B" -> "Before")`
                6.  `scala.collection.mutable.HashaMap("A" -> "Abuout", "B" -> "Before")`
            3. IO
                1. `scala.io.Source`
                2. `Console`
                3. `java.io.File`
    2. Primitive
        1. Numeric
            1. Interger
                1. Byte: 8 bits, `-2^7 ~ 2^7 -1`
                2. Short: 16bits, `-2^15 ~ 2^15 - 1`
                3. Int: 32 bits, `-2^31 ~ 2^31 - 1`
                4. Long: 64 bits, `-2^63 ~ 2^63 - 1`
            2. Float
                1. Float: 32 bits IEEE 754 single-precision float
                2. Double: 64 bits IEEE 754 single-precision float
            3. Literal
                1. `12`: int, base 10
                2. `0x5, 0xff`: int, base 16
                3. `12L`: long
                4. `1.0, 1.0e10, 1.0d 1.0D`: double
                5. `1.0f 1.0F`: float
            4. Methods
                1. `.to()`: `(0).to(3), 0 to 3`, include 0 and 3
                2. `0 unitl 3`: include 0, excluding 3
                3. `.toString()`
                4. `.toBinaryString()`
                5. `.numberOfTrailingZeros()`
                6. `.max(10)`
                7. `.min(10)`
                8. `.abs()`
        2. Char: 16 bits unsigned unicode character, `0 ~ 2^16 - 1`
            1. Literal
                1. `'A'`: unicode character between single quote ''
                2. `'\uxxxx'`: `x` is hex digit, '\u0041' '\u00fa'
            2. Escaping
                1. `'\b'`: backspace
                2. `'\t'`: tab
                3. `'\n'`: line feed
                4. `'\f'`: form feed
                5. `'\r'`: carrige return
                6.  `'\"'`: double quote
                7.  `'\''`: single quote
                8.  `'\\'`: backslash
            3. Methods
                1. `.toByte()`
        3. Boolean: `[true, false]`
        4. Unit
            1. `()` value
            2. `Unit` returned when function returns no value
            3. `Unit == ""`: return `false`
    3. Complex
        1. Option
            1. value
                1. `Some(10), Some("hello")`
                2. `None`
            2. methods
                1. `.getOrElse("unknown")`
            
            ```scala
            optionValue match {
                case some(v) => println("hello" + v")
                case None => println("hello")
            }
            ```
        2. String
            1. Literal
                1. single quote: `"hello, world"`
                2. triple quotes

                    ```scala
                    """hello,
                        world!"""
                    =>
                    hello,
                        world!

                    """|hello,
                       |world!""".stripMargin
                    =>
                    hello,
                    world!
                    ```
            2. Methods
                1. `+`: concatenate strings
                2. `*`: concatenate string multiple times
                3.  `.length`
                4.  `.isEmpty`
                5. `.toLowerCase()`
                6. `.toUpperCase()`
                7.  `.captalize()`
                8.  `.[toByte, toShort, toInt, toLong, toFloat, toDouble]()`
                9.  `.mkString()`
                10. `.substring()`
                11. `.split()`
                12. `.endsWith()`
                13. `.matches()`
                14. `.contains()`
                15. `.trim()`
                16. `.drop(2)`
                17. `.stripMargin()`
                18. `s"hello, $name, age is: ${6 * 7}"`: string interpolates
                19. `raw"no\\\\escape!" => no\\\\escape!`: raw string will not escape
                20. `f"${math.pi}%.5f"`: printf-style formatting, when no `"%"`, then default is "%s", the toString value
        3. List
            1. Literal
                1. `Nil`: same as `List()`, an emply list
            2. Methods
                1. `::`: prepend a new element to the beginning of an existing list and returns the new list
                2. `:::`: concatenas list
                3. `.length`: get the number of the elements
                4. `.isEmpty`: determine whether the list is empty
                5. `.head`: get the first element
                6. `.last`: get the last element
                7. `.init`: get all but the last element
                8.  `.tail`: get all but the first element
                9.  `.reverse` - gets a reversed list
                10. `.sorted` - gets a sorted list
                11. `.count(s => s.length == 4)`: get number of elements with length 4
                12. `.exists(s => s == "util")`: determin whether exists a `"util"` element
                13. `.contains("util")`
                14. `.forall(s => s.endsWith("l"))`: determin whether all elements ends with "l"
                15. `.mkString(",")`: makes a string using giving delemiter
                16. `.map(s => s + "y")`
                17. `.foreach(s => println(s)) <=> .foreach(println)`: execute on each elements
                18. `.filter(s => s.length == 4)`
                19. `.filterNot(s => s.length == 4)`: get the opposite elements of `.filter()`
                20. `.reduceLeft((a, b) => if (a.length > b.length) a else b`
                21. `.sortWith((s, t) => s.charAt(0).toLower < t.charAt(0).toLower)`: get list ordered by the first lowered char
                22. `.drop(2)`: drop the first 2 elements
                23. `.dropRight(2)`: drop the rightmost 2 elements
            
            ```scala
            val oneTwo = List(1, 2)
            val threeFour = List(3, 4)
            oneTwo ::: threeFour
            1 :: oneTwo <=> oneTwo.::(1)
            val ontTwoThree = 1 :: 2 :: 3 :: Nil
            ```
        4. Array
            1. Property
                1. Arrays are mutable, but fixed-length
                2. when using new Array, 0 for numeric array, false for Boolean, null for String, and other types
            2. Initialization
                1. `new Array[T](length)`
                2. `Array(1, 3, 5)`
                3. `Array("hello", "world")`
        5. LIstBuffer
            1. Methods
                1. `.toList`
        6. Tuple
            1. Literal
                1. `val pair = (99, "buffer")`: initialize using `()`
                2. `pair._2`: accesse individual with ._N, N starts with 1, up to 22
                3. `.productIterator`
        7. Set & Map
            1. Methods
                1. `+=`: append a item, not apply for immutable
                2. `.contains("A')`
            
            ```scala
            val x = new HashMap[Int, String]()
            var direct = Map("A" -> "About", "B" -> "Before")
            direct += ("C" -> "Center")
            direct("C")
            ```
        8. Range
            1. Methods
                1. `0 to 3`
                2. `0 until 3`
        9.  Source
            1. Methods
                1. `Source.fromFile("hello.txt")`: read file from normal path
                2. `Source.fromResource("hello.txt").getLines`: read file from `resources` folder, `scalaVersion >= 2.13`
        10. Console
            1. `Console.print()`
            2. `Console.println()`: end with a linefeed
            3. `Console.out.println()`
            4. `Console.err.println()`
        11. File
            1. `.listFiles()`
            2. `.getName()`
5. Syntax
    1. Base
        1. `[// ...,  /* ... */]`: comments
        2. `Summer.scala`: scala file name follows the class or object name
    2. Identifiers
        1. start with a letter or underscore, then letters, digits, or underscore
        2. `$` also counts as a letter, reserved for compiler which should be avoided to use
        3. avoid identifiers like `__init__` or `name_` for underscore has other non-identifiers usage in scala
        4. use camel-case style, e.g., `toString`
        5. constant names also follow camel-case, with the first character upper case, such as `XOffset`
        6. followings should start with a lower case letter
            1. variable
            2. field
            3. method parameter
            4. function
        7. following should start with an upper case letter
            1. class
            2. trait
    3. Variable
        1. `val`: initialized once, cannot be reassigned, similar to a final variable in Java
        2. `var`: can be reassigned
        3. same name variable can not be defined in the same scope, different scope can define same name
    4. Operator
        1. Infix Operator
            1. infix operator invokes method to sit between the object and the parameter
            2. when the method takes multiple arguments, the arguments should be placed in parentheses `()`

            ```scala
            val s = "hello, world"
            s indexOf 'o' <=> s.indexOf('o')
            s indexOf ("o", 5) <=> s.indexOf("o", 5)
            ```
        2. Prefix Operator: only the following four identifiers can be prefix operator
            1. `+`
            2. `-`
            3. `!`
            4. `~`

            ```scala
            -2.0 <=> (2.0).unary_-
            !a <=> a.unary_!
            ~1 <=> 1.unary_~
            ```
        3. Postfix Operator
            1. postfix operators takes no arguments, which can be invoked without a dot or parentheses
            2. if the method has side effects, the convention is to include parentheses, such as `.print()`

            ```scala
            val s = "hello, world"
            s toLowerCase <=> s.toLowerCase
            ```
        4. Arithmetic Operator
            1. `+ - * / %`
            2. `+ -`: positive and negative sign
        5. Relational Operator 
            1. `> < >= <= != ==`
            2. `this == that <=> if (this eq null) that eq null else this.equals(that)`: compares contents
            3. `this eq that, this ne that`: determine whether this and that beging the same object reference
            4. `null == null && null eq null <=> true`
        6. Logical Operator
            1. `&&, ||`: short-circuit
            2. `&, |`: all will be evaluated
            3. `!`: invert a boolean value
        7. Bitwise Operator
            1. `& | ^ ~`
            2. `<<, >>`: signed left and right shift
            3. `>>>`: unsigned right shift
            4. `<<, >>>`: fill with zeroes
            5. `>>`: fill with the highest sign bit of the left-hand value
        8. Assignment Operator
            1. `= += -+ *= /= %=`
        9.  Operator Precedence
            1. Property
                1. precedence is based on the first character of the methods used in operator notation
                2. if the operator ends with `=`, and the operator is not in `<=, >=, ==, !=`, then the precedence is same as `=`
            2. Order
                1. all other special characters
                2. `+ / %`
                3. `+ -`
                4. `:`
                5. `== !=`
                6. `< >`
                7. `&`
                8. `^`
                9. `|`
                10. all letters
                11. all assignment operators
            3. Examples
                1. `2 << 2 + 2 <=> 2 << (2 + 2)`: the starting `<` is lower than `+`
                2. `x *= y + 1 <=> x *= (y + 1)`: `*=` precedence is same as `=`
        10. Operator Associativity
            1. the associativity is based on the last character `:`
            2. any operator ending with a `:` is invoked on its right operand, passing in the left operand
            3. methods ending with other character are invoked on their left operand, passing in the right operand

            ```scala
            a * b <=> a.*(b)
            a ::: b <=> b.:::(a)
            ```
6. Control Structure
    1. Conditonal
        1. If
            1. `if (boolean) {...}`: `if` returns a value
            2. `if (boolean) {...} else if {...} else {...}`
        2. Match
            1. return a value, which can be stored in a variable
            2. any kind of constant can be used, not just integer-type, enum and string contants in Java's case statements
            3. no break at the end of each case. it is implicit, therefore there is no fall through from one to the next
            4. `_` for unknown value
        
        ```scala
        val firstArg = if (args.length > 0) args(0) else ""    
        firstArg match {
            case "salt" => println("pepper")
            case "chips" => println("salsa")
            case "eggs" => println("bacon")
            case _ => println("huh?")
        }
        
        val firstArg = if (!args.isEmpty) args(0) else ""
        val friend = firstArg match {
                case "salt" => "pepper"
                case "chips" => "salsa"
                case "eggs" => "bacon"
                case _ => "huh?"
        }           
        println(friend)
        ```
    2. Looping
        1. while: return a `Unit` value
            1. `while (boolean) {...}`
            2. `do {...} while (boolean)`
        2. for
            1. `for (arg <- args) {...}`: arg is a val type generated in each iteration;  `<-` means `in`
            2. `for (arg <- args if arg % 2 == 0) {...}`: with `if` filter
            3. `for (arg <- args; brg <- brgs) {...}`: multiple `<-`
            4. `for (...) yield {...}`: `yield` collects values in each iteration
        3. Notes
            1. scala leaves out break and continue command, they do not mesh well with function literals
            2. the simplest approach is to replace every continue by an if and every break by a boolean variable

            ```scala
            // use ()
            for (
                file <- filesHere
                if file.getName.endsWith(".scala");
                line <- fileLines(file)
                if line.trim.matches(pattern) 
                ) println(file + ": " + line.trim)

            // use {}, for multiple line ";" can be omitted
            for {
                 file <- filesHere
                    if file.getName.endsWith(".scala")
                    line <- fileLines(file)
                    trimmed = line.trim
                    if trimmed.matches(pattern)  
                } println(file + ": " + trimmed)

            // use yield 
            val forLineLengths =
                for {
                    file <- filesHere
                    if file.getName.endsWith(".scala")
                    line <- fileLines(file)
                    trimmed = line.trim
                    if trimmed.matches(".*for.*")  
                } yield trimmed.length

            // java use break and continue
            int i = 0;
            boolean foundIt = false;
            while (i < args.length) {
                if (args[i].startsWith("-")) {
                  i = i + 1;
                  continue;
                }
                if (args[i].endsWith(".scala")) {
                  foundIt = true;
                  break;
                }
                i = i + 1;
            }

            // scala use var variables
            var i = 0
            var foundIt = false
            while (i < args.length && !foundIt) {
                if (!args(i).startsWith("-")) {
                    if (args(i).endsWith(".scala"))
                        foundIt = true
                }
                i = i + 1
            }

            // scala use a recursive function, without var variables
            def searchFrom(i: Int): Int =
                if (i >= args.length) -1
                 else if (args(i).startsWith("-")) searchFrom(i + 1) 
                 else if (args(i).endsWith(".scala")) i
                 else searchFrom(i + 1)
            val i = searchFrom(0)
            ```
7. Function
    1. Properties
        1. parameters are val type
        2. `return` at the end of function can be omitted, then the last value is returned
        3. a function's side effect is generally defined as mutating state external to the method or performing io action
        4. a functional style prefers vals, immutable objects, and methods without side effects
        5. use vars, mutable objects, and methods with side effects when you have a specific need and justification for them
    2. Literal
        1. `(x: Int, y: Int) => x + y`: specify parameter type
        2. `someNumbers.filter(x => x > 0)`: without parameter type
        3. `someNumbers.filter(_ > 0)`: `_` is placeholder for parameter syntax, when each parameter appears only once
        4. `someNumbers.foreach(println _) <=> someNumbers.foreach(x => println(x))`: placeholder for an entire parameter list, not just a single parameter, require a space between function name and `_`
        5. `someNumbers.foreach(println _) <=> someNumbers.foreach(println)`: `_` can be omitted when a function is invoked as a method reference, otherwise causes an error
    3. Definition
        1. regular

            ```scala
            def max(x: Int, y: Int): Int = {
                if (x > y) x
                else y
            }
            ```
        2. with repeated parameters

            ```scala
            def echo(args: String*) = {}
            echo(arr: _*)
            ```
        3. with named arguments

            ```scala
            def speed(distance: Float, time: Float): Float = distance / time
            speed(distance = 100, time = 10)
            ```
        4. with default parameter values

            ```scala
            def printTime(out: java.io.PrintStream = Console.out) =
                out.println("time = " + System.currentTimeMillis())
            ```
        5. multiple parameter lists

            ```scala
            def myLoop(start: Int, end: Int) (callback: Int => Unit) = {
                for (i <- Range(start, end)) {
                    callback(i)
                }
            }

            myLoop(start = 5, end = 10) { i => println(s"i has value ${i}")}
            ```
8. Class
    1. Scala
        1. Initialization
            1. New
                1. `val big = new java.math.BigInteger("12345")`: parameterize with value
                2. `val greetStrings = new Array[String](3)`: parameterize with type and length
            2. Factory Method
                1. Properties
                    1. a factory method calls an `apply` method, which creates and returns the new object
                    2. the `apply` method is defined on the corresponding companion class which seems like calling a static method     from the class
                2. Examples
                    1. `arr(2) <=> arr.apply(2)`: a variable surrounded by `()` invocates an `apply` method on that variable
                    2. `val greetStrings = Array("zero", "one", "two") <=> Apply.apply("zero", "one", "two")`
                    3. `arr(2) =  "hello" <=> arr.update(2, "hello")`: an assignment invocates an update method
                    4. `1 -> "Go" <=> (1).->("Go")`: `->` can be invoked on any object, returns a two-element tuple, see Map
        2. Modifiers
            1. `public`: default, no need to specify
            2. `private`
            3. `protected`: only accesible for subclasses of the class in which the member is defined
            4. `override`
            5. `require`: `require(d != 0)` defined in standalone object `Predef`
            6. `this`: self reference
            7. `this(n: Int) = this(n, 1)`: auxiliary constructor must invoke another constructor of the same class first. the     primary construction is the final single point of entry of a class, and the only calls supclass constructor
        3. Definition
            1. Regular
    
                ```scala
                class ChecksumAccumulator {
                    private var sum = 0
                    def add(b: Byte): Unit = { sum += b }
                    def checusum(): Int = ~(sum & 0xff) + 1
                }
    
                class Rational(n: Int, d: Int) {
                    require(d != 0)
                    val numer: Int = n
                    val denom: Int = d
    
                    def this(n: Int) = this(n, 1) // auxiliary constructor
    
                    override def toString = numer + "/" + denom
    
                    def add(that: Rational): Rational =
                        new Rational(
                          numer * that.denom + that.numer * denom,
                          denom * that.denom
                        )
    
                    def + (that: Rational): Rational =
                        new Rational(
                          numer * that.denom + that.numer * denom,
                          denom * that.denom
                        )
    
                    def lessThan(that: Rational) = 
                        this.numer * that.denom < that.numer * this.denom
    
                    def max(that: Rational) = 
                        if (this.lessThan(that)) that else this
                }
                ```
            2. singleton object
                1. a singleton function behavies like a static method in Java
                2. share same name with a class, it is called that class's companion object. 
                3. the class is called the companion class of the singleton. they are defined in the same source file.
                4. the class and the singleton can access each other's private members
                5. a singleton wihout a companion class is a standalone object. it can collect utility methods or become an app's     entry point
                6. the entry point has a `main` method, takes an `Array[String]` parameter and returns a `Unit` value, e.g.,
    
                    ```scala
                    import ChecksumAccumulator.calculate
      
                    object Summer {
                        def main(args: Array[String]): Unit = {
                            for (arg <- args)
                                println(arg + ": " + calculate(arg))
                            }
                    }
                    ```
                
                ```scala
                import scala.collection.mutable
      
                object ChecksumAccumulator {
                    private val cache = mutable.Map.empty[String, Int]
    
                    def calculate(s: String): Int = 
                        if (cache.contains(s))
                            cache(s)
                        else {
                            val acc = new ChecksumAccumulator
                            for (c <- s)
                                acc.add(c.toByte)
                            val cs = acc.checksum()
                            cache += (s -> cs)
                            cs
                          }
                }
    
                val ca = ChecksumAccumulator.calculate("Every value is an object.")
                ```
            3. Case Class
                1. Properties
                    1. automatically create a singleton object, which has following methods and traits
                        1. Methods
                            1. `apply())`
                            2. `unapply()`: for pattern match
                            3. `copy()`: `val b = a.copy()`
                            4. `toString()`
                            5. `hashCode()`
                            6. `equals()`: instances are compared by structure and not by reference
                        2. Inherited Traits
                            1. `Product`
                            2. `Serializable`
                    2. suitable for immutable data, parameters are public val types
                2. Definitions
    
                    ```scala
                    case class Person(name: String, age: Int)
                    ```
            4. Case Object:
                1. Properties
                    1. similar to case class, but without `apply()` and `unapply()` methods
                    2. use when no parameters are needed 
            5. `scala.APP` Trait
                1. work like a singleton object with a `main` method, use `args` to access command-line arguments
    
                ```scala
                import ChecksumAccumulator.calculate
      
                object FallWinterSpringSummer extends App {
                    for (season <- List("fall", "winter", "spring"))
                        println(season + ": " + calculate(season))
                }
                ```
9.  Exception
    1. Java
        1. Catch or Specify Requirement: code that might throw exceptions must be enclosed by either of the following, otherwise the code will not be compiled
            1. A `try` statement that catches the excpetion. The `try` must privide a handle for the exception
            2. A method specifies it can throw the exception. The method must provide a `throws` clause listing the exception
        2. Structure
            1. Throwable
                1. Error
                    1. `java.io.IOError`
                    2. other subclasses
                2. Exception
                    1. RuntimeException
                        1. `NullPointerException`: occur when a method access a member of an object through a null reference
                        2. `IndexOutOfBoundsException`
                        3. other subclasses
                    2. Other subclasses
                        1. `java.io.IOException`
                        2. `java.io.FileNotFoundException`
                        3. other subclasses
        3. Types
            1. Checked Exception
                1. Exception
                    1. Should anticipate and recover from
                    2. All exceptions are checked exceptions, except for `Error` and `RuntimeException` and their subclasses
                    3. **Subject to the Catch or Specify Requirement**
                    4. A well-written program will catch this exception and notify the mistake
            2. Unchecked Exceptions
                1. Error
                    1. External to the application which usually cannot anticipate or recover from
                    2. Indicated by `Error` and its subclasses
                    3. **Not subject to the Catch or Specify Requirement**
                    4. Might catch this exception in order to notify the problem, but makes sense to print a stack trace and exit
                2. Runtime Exception
                    1. Internal to the application that cannot anticipate or recover from, indicating bugs such as logic error or     improper use of API
                    2. Indicated by `RuntimeException` and its subclasses
                    3. **Not subject to the Catch or Specify Requirement**
                    4. Can catch this exception, but it probably makes more sense to eliminate the bug that caused the excption
        4. Exception Handlers
            1. Exception Methods
                1. `e.getMessage()`
                2. `e.printStackTrace()`
                3. `e.getSuppressed()`
            2. try-catch-finally
                1. `try`: work with at least one of `catch` or `finally`
                2. `catch`
                    1. a single handler with one exception
    
                        ```java
                        try {
                            ...
                        }
                        catch (Exception e) {
                            ...
                        }
                        ```
                    2. a single handler with multiple type exceptions
                        1. the `catch` parameter is implicitly `final`, so it cannot be assigned any other value within the catch block
                        2. since Java SE7
    
                        ```java
                        try {
                            ...
                        }
                        catch (Exception1|Exception2 e) {
                            ...
                        }
                        ```
                    3. multiple handlers
    
                        ```java
                        try {
                            ...
                        }
                        catch (Exception1 e1) {
                            ...
                        }
                        catch (Exception2 e2) {
                            ...
                        }
                        catch (Exception1|Exception2 e) {
                            ...
                        }
                        ```
                3. `finally`: always execute when the try block exits
                    1.  if the JVM exits while the `try` or `catch` code is being executed, then the `finally` block may not execute
                    2.  if the thread executing the `try` or `catch` code is interrupted or killed, the `finally` block may not     execute even though the application as a whole continues
            3. try-with-resources
                1. since Jave SE7
                2. any object that implements `java.lang.AutoCloseable`, including all objects which implement `java.io.Closeable`,     can be used as a resource. The `Closeable` interface extends the `AutoCloseable` interface
                    1.  the `close` method of the `AutoCloseable` interface throws exceptions of type `Exception`
                    2.  the `close` method of the `Closeable` interface throws exceptions of type `IOException`
                3. multiple resources can be separated by a semicolon `;`. `close` methods of resources are called in the opposite     order of their creation
                4. a try-with-resources statement can have `catch` and `finally` blocks just like an ordinary `try` statement. in a try-with-resources statement, any `catch` or `finally` block is run after the resources declared have been closed
    
                ```java
                try (inputStream = new FileReader("in.txt");
                    outputStream = new FileWriter("out.txt")) {
                    ...
                } catch (Exception e) {
                    ...
                }
                ```
            4. Method Throws Exceptions: not catch the exception, but allow further up the call stack to handle it

                ```java
                public void writeList() throws IOException, OtherException, ... { ...}
                ```
            5. Throw statement: `throw new IOException()`
    2. Scala
        1. `throw new IllegalArgumentException`: `throw` has type `Nothing`
        2. `try{} catch{} finally {}`: returns a value, if exception thrown not caught, the expression has no result at all
        3. the value computed in the `finally` clause will be dropped, it usually does some clean work
        4. if `finally` has explicit return, or throws an exception, the return value or exception will the final expression result
    
            ```scala
            def f(): Int = try return 1 finally return 2 => f() => 2
            def g(): Int = try 1 finally 2 // g() => 1
            ```
    
        ```scala
        def urlFor(path: String) =
            try {
                new URL(path)
            } catch {
                case e: MalformedURLException =>
                new URL("http://www.scala-lang.org")
            }
        
        try {
            val file = new FileReader("input.txt")
            ...
        } catch {
            case ex: IOException => // Handle I/O error
            case ex: _ => // Handle other condition
        } finally {
            file.close()
        }
        ```
10. Package & Import
    1. Package
        1. Create 
            1. name convention is using reversed Internet domain names to avoid potential name conflicts
            2. statement must be placed at the top of every source file: `package com.test`
            3. source file must be placed in directories matching the package name
    2. Import: allow using a simple package element name
        1. Usage

            ```scala
            import scala.collection.mutable
            var helloSet = mutable.Set("hello", "world")
            ```
        2. Automatically import packages
            1. Java
                1. `java.lang`: but its sub packages are not included
                2. the package the current class is located
            2. Scala
                1. `java.lang`
                2. `scala`
                3. `Predef`
                    1. `println` invokes `Predef.println`, which invokes `Console.println`
                    2. `assert` invokes `Predef.assert`
11. Libraries
    1. `java.lang`
        1. System
            1. `System`
                1. `.exit(n)`: `System.exit(1)`
                2. `.arraycopy()`: `System.arraycopy(copyFrom, 2, copyTo, 0, 7)`
                3. `.getProperty(name)`
                    1. `.getProperty("line.separator")`
                    2. `.getProperty("file.encoding")`
                    3. `.getProperty("user.home")`
            2. `System.in` 
                1. `InputStreamReader cin = new InputStreamReader(System.in)`: use standard input as a character stream
            3. `System.out`
                1. `.println()`
                2. `.format()`: specifiers begin with `%`
                    1. `%d`: integer value
                    2. `%x`: hexadecimal value
                    3. `%f`: floting value
                        1. `%f+20.10f`: precision 10, width 20,  use sign flags padding with 0
                        2. `%1$+20.10f`: use argument index 1 with `1$`
                        3. `%<+20.10f`: use the same argument as the previous specifier 1 with `<`
                    4. `%s`: format as a string
                    5. `%n`: platform-specific line terminator
                    6. `%%`: output `%`
            4. `System.err`: similar to `System.out`
            5. `Console: System.console()`
                1. `.readLine()`
                2. `.readPassword()`
                3. `.format()`
        2. `Object`
        3. `Character`
            1. `Character.isLetter(ch)`
        4. `String`
            1. Properties
                1. immutable, once created, never change
            2. Constructor
                1. literal: `String greet = "hello";`
                2. new: `String greet = new String("hello");`
            3. Members
                1. `+`: concatenate strings, create a new string, `"hello" + "world"`
                2. `.length()`
                3. `.charAt(0)`
                4. `.indexOf(target)`: return the first index number found, or `-1` returned when not found
                    1. `.indexOf(target)`
                    2. `.indexOf(target, fromIndex)`
                5. `.lastIndexOf(target)`: search from right to left
                    1. `.lastIndexOf(target)`
                    2. `.lastIndexOf(target, fromIndex)`
                6. `.equals(anotherString)`
                7. `.equalsIgnoreCase(anotherString)`
                8. `.toLowerCase()`
                9. `.toUpperCase()`
                10. `.trim()`
                11. `.substring(start, end)`:  between `.charAt(start)` and `.charAt(end)`
                12. `.sbustring(start)`: equal `.substring(start, .length() -1)`
                13. `.toCharArray()`
    2. `java.math`
        1. `BigDecimal`: used for precise values, such as currency
            1. Constructor
                1. `BigDecimal("19.99")`
            2. members
                1. `.add()`
                2. `.multiply()`
    3. `java.util`
        1. `Calendar`
            1. Members
                1. `Calendar.getInstance()`: get a calendar using the default time zone and locale
            2. Formats
                1. `tY`: year `yyyy`
                2. `ty`: year `yy`
                3. `tm`: month, `mm`
                4. `tB`: month name `November`
                5. `tb`: month name abbr `Nov`
                6. `tA`: weekday `Monday`
                7. `ta`: weekday abbr `Mon`
                8. `td`: day `dd`
                9. `te`: day `d`
                10. `tH, tk`: hour `hh`, base on 24
                11. `tl`: hour `hh` based on 12
                12. `tM`: minutes `mm`
                13. `tS`: seconds `ss`
                14. `tL`: milliseconds `490`
                15. `tN`: nanoseconds `570000000`
                16. `tp`: `am/pm`
                17. `tz`: timezone `+0800`
                18. `tZ`: timezone abbr `CST`
                19. `ts`: timestamp seconds
                20. `tQ`: timestamp milliseconds
                21. `tF`: `yyyy-mm-dd`
                22. `tR`: `hh:mm` based on 24
                23. `tT`: `hh:mm:ss` based on 24
                24. `tr`: `hh:mm:ss am/pm`
        2. `Properties`

            ```scala
            val connectionProperties = new Properties()
            connectionProperties.put("user", "username")
            ```
        3. `Locale`
            1. `Locale.SIMPLIFIED_CHINESE`
        4. `Scanner`: use while space to separate tokens, including blanks, tabs and line terminators
            1. `.useDelimiter(",\\s*")`
            2. `.useLocale(Locale.SIMPLIFIED_CHINESE)`
            3. `.hasnext()`
            4. `.hasNextDouble()`
            5. `.next()`
            6. `.nextDouble()`
            7. `.close()`

            ```java
            s = new Scanner(new BufferReader(new FileReader("hello.txt")));
            while (s.hasNext()) {
                System.out.println(s.next());
            }
            ```
        5. `Arrays`
            1. `Arrays.equals()`: `Arrays.equals(chars, "123".toCharArray())`
            2. `Arrays.fill()`: `Arrays.fill(name, ' ')`
            3. `Arrays.copyOfRange()`: `String[] copyTo = java.util.Arrays.copyOfRange(copyFrom, 2, 9);`, include start, exclude end
            4. `Arrays.binarySearch()`
            5. `Arrays.sort()`
            6. `Arrays.parallelSort`: since Java SE8, concurrently execute
        6. `List`
        7. `ArrayList`
    4. `java.io`
        1. Byte Streams
            1. `InputStream`
                1. `FileInputStream`
                2. `ByteArrayInputStream`
                3. `ObjectInputStream`
                    1. implement interface `ObjectInput` which implements `DataInput`
                    2. support primitive types and objects which implements interface `Serializable`
                    3. methods
                        1. `.readObject()`
                4. `FilterInputStream`
                    1. `BufferedInputStream`
                    2. `DataInputStream`
                        1. implement interface `DataInput`
                        2. detect an end-of-file condition by catching `EOFException`
                        3. support primitive types and String values
                            1. `.readUTF()`: read string value
                            2. `.readDouble()`
                    3. `PushbackInputStream`
            2. `OutputStream`
                1. `FileOutputStream`
                2. `ByteArrayOutputStream`
                3. `ObjectOutputStream`
                    1. implement interface `ObjectOutput` which implements interface `DataOutput`
                    2. support primitive types and objects which implements interface `Serializable`
                    3. methods
                        1. `writeObject()`
                4. `FilterOutputStream`
                    1. `BufferedOutputStream`
                    2. `DataOutputStream`
                        1. implement interface `DataOutput`
                        2. support primitive types and String values
                            1. `.writeUTF()`: write out string values in a modified of UTF-8
                            2. `.writeDouble()`
                    3. `PrintStream`
        2. Chracter Streams
            1. `Reader`
                1. `InputStreamReader`
                    1. `FileReader`
                2. `CharArrayReader`
                3. `StringReader`
                4. `BufferedReader`
                    1. Members
                        1. `.readLine()`
                    2. Subclasses
                        1. `LineNumberReader`
                5. `FilterReader`
                    1. `PushbackReader`
                6. `PipedReader`
            2. `Writer`
                1.  `OutputStreamWriter`
                    1. `FileWriter`
                2. `CharArrayWriter`
                3. `StringWriter`
                4. `BufferedWriter`
                5. `PrintWriter`
                6. `FilterWriter`
                7. `PipedWriter`
        3. `File`
    5. `java.nio`: since Jave SE7
        1. `java.nio.charset`
            1. `Charset`
                1. `Charset.forName("US-ASCII")`
                    1. `US-ASCII`
                    2. `UTF-8`
        2. `java.nio.file`
            1. `Path`
                1. Properties
                    1. store names as a sequence, from the highest element in the directory stucture with index 0 (the element closet to the root, `home` in `/    home/tom`), and the lowest element with index `n-1`
                2. Members
                    1. `path = Paths.get("/home/tom")`
                    2. `.toString()`
                    3. `.toUri()`
                    4. `.toAbsolutePath()`
                    5. `.toRealPath()`
                    6. `.resolve(path_name)`: join two path, append to original path
                    7. `.relative(p2)`: path between two paths
                    8. `.equals(otherPath)`
                    9. `.startsWith(beginPath)`
                    10. `.endsWith(endPath)`
                    11. `.getFileName()`
                    12. `.getName(0)`
                    13. `.getNameCount()`
                    14. `.subpath(0, 2)`: exclude a root element, `home/tom` in `/home/tom`
                    15. `.getParent()`
                    16. `.getRoot()`
            2. `Files`
                1. Properties
                    1. glob
                        1. `*`: match none or any number characters of a name without crossing directory boundaries
                        2. `**`: work like `*` but crosses directory boundaries, generally used for matching complete paths
                        3. `?`: match exactly one character
                        4. `{}`: specify a collection of subpatterns separated by `,`
                            1. `{sun, moon, stars}`
                            2. `{temp*, tmp*}`
                        5. `[]`: match a character in a set, `-` used for a range. within `[]`, `*`, `?` and `\`. `-` matches itself when it is the first character within the brackets, or the first character after the `!` if negating
                            1. `[aeiou]`
                            2. `[0-9]`
                            3. `[a-zA-Z]`
                            4. `[!a-c]`
                        6. `\`: excape some characters
                        7. all other characters match themselves
                2. Methods
                    1. `Files.newBufferedWriter()`
                    2. `Files.move()`
            3. Exception
                1. `FileSystemException`
                    1. Members
                        1. `.getFile()`
                        2. `.getMessage()`
                        3. `.getReason()`
                    2. Subclasses
                        1. `NoSuchFileException`
    6. JDBC
        1. General
            1. Reference: [Java JDBC Documents](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html)
            2. import class: `import java.sql._`
            3. register driver, no need since JDBC4: `Class.forName(driver)`
            4. get connection: `connection = java.sql.DriverManager.getConnection(url, user, pwd)`
            5. statements
                1. prepare statem
                    ```scala
                    query = "insert into tbl (a, b) values (?, cast(?) as real)"
                    statement = connection.prepareStatement(query)
                    statement.setString(1, value(1).toString)
                    statement.setString(2, value(2).toString)
                    statement.executeUpdate()
                    ```
            6. Executtion
                1. `statement.executeQuery()`
                2. `statement.executeUpdate`
            7. Result
                ```scala
                rs = stmt.executeQuery(query)
                while (rs.next()) {
                    rs.getInt("cof_name")
                }
                ```
            8. comm
                ```scala
                connection = ...
                connection.setAutoCommit(false)
                ...
                connection.commit()
                
        2. Database
            1. PostgreSQL
                1. Dependencies: `"org.postgresql" % "postgresql" % "42.2.16"`
                2. Jar: [postgresql](https://jdbc.postgresql.org/download.html)
                3. Document: [PgJDBC driver documentation](https://jdbc.postgresql.org/documentation/head/)
                4. Driver: `org.postgresql.Driver`
                5. Url: `jdbc:postgresql://host:port/dbname?user=u&password=p`
            2. MySQL
                1. Dependencies: `"mysql" % "mysql-connector-java" % "8.0.25"`
                2. Jar: [mysql-connector-java](https://dev.mysql.com/downloads/connector/j/)
                3. Driver: `com.mysql.cj.jdbc.Driver`
                4. Url: `jdbc:mysql://host:port/dbname?user=u&password=p`
            3. SQL Server 
                1. Url SQL Server 2000: `jdbc:sqlserver://host:port;database=dbname;user=u;password=p`
            4. Hive
                1. Dependencies: `"org.apache.hive" % "hive-jdbc" % "3.1.2"`
                2. Jar: [hive-jdbc-uber-jar](https://github.com/timveil/hive-jdbc-uber-jar/releases)
                3. Driver: `org.apache.hive.jdbc.HiveDriver`
                4. Url
                    1. `jdbc:hive2://host:port/dbname`
                    2. `jdbc:hive2://host:port/dbname;user=<user>;password=<password>`: LDAP
    7. Other Databases
        1. Hbase
            1. Dependencies: `"org.apache.hbase" % "hbase-client" % "2.3.5"`
            2. Initialization
    
                ```scala
                import org.apache.hadoop.hbase.{HBaseConfiguration, HConstants, TableName, CellUtil}
                import org.apache.hadoop.hbase.client.{ConnectionFactory, Scan, Put, Get}
                import org.apache.hadoop.hbase.util.Bytes
    
                val config = HBaseConfiguration.create()
                config.set(HConstants.ZOOKEEPER_QUORUM, "hpmaster")
                //conf.set("hbase.zookeeper.quorum", "hpmaster")
    
                val connection = ConnectionFactory.createConnection(config)
                connection.close()
                ```
            3. Operations
                1. Admin
                    1. Admin Initialization
    
                        ```scala
                        val admin = connection.getAdmin
                        admin.tableExists(TableName.valueOf("ns:test"))
                        ...
                        admin.close()
                        ```
                    2. Operations
                        1. exists:`admin.TableExists(TableName.valueOf(table_name))`
                        2. create: `admin.createTable(...)`
                        3. drop:
                            1. `admin.disableTable(TableName.valueOf(table_name))`
                            2. `admin.deleteTable(TableName.valueOf(table_name))`
                2. Table
                    1. Table Initialization
    
                        ```scala
                        val table = connection.getTable(TableName.valueOf("ns:test"))
                        ...
                        table.close()
                        ```
                    2. Scan Rows
    
                        ```scala
                        def printRow(result : Result) = {
                          val cells = result.rawCells();
                          print( Bytes.toString(result.getRow) + " : " )
                          for(cell <- cells){
                            val col_name = Bytes.toString(CellUtil.cloneQualifier(cell))
                            val col_value = Bytes.toString(CellUtil.cloneValue(cell))
                            print("(%s,%s) ".format(col_name, col_value))
                          }
                          println()
                        }
    
                        /**
                        val scan = new Scan()
                        scan.addFamily(columnFamily.getBytes())
                        var scanner = table.getScanner(scan)
                        var result = scanner.next()
                        while (result != null) {
                          println(Bytes.toString(result.getRow))
                          result = scanner.next()
                        }
                        scanner.close()
                        */
                        var scan = table.getScanner(new Scan())
                        scan.forEach(result => {printRow(result)})
                        scan.close()
                        ```
                    3. Get Row
    
                        ```scala
                        // Bytes.toBytes("ab") <=> "ab".getBytes()
                        val get = new Get(Bytes.toBytes("rowid"))
                        var result = table.get(get)
                        println(Bytes.toString(result.getRow))
                        println(Bytes.toString(result.getValue(Bytes.toBytes("column_family"), Bytes.toBytes("col_name"))))
                        ```
                    4. Put Row
    
                        ```scala
                        var put = new Put(Bytes.toBytes("rowid"))
                        put.addColumn(Bytes.toBytes("column_family"), Bytes.toBytes("col_name"), Bytes.toBytes("value"))
                        table.put(put)
                        ```
                    5. Delete Row
    
                        ```scala
                        val del = new Delete(Bytes.toBytes(rowkey))
                        del.addColumn("column_family".getBytes(), "column_name".getBytes())
                        table.delete(del)
                        ```
