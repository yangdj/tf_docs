# Scala

## SBT

1. References
    1. [scaladex](https://index.scala-lang.org/)
    2. [sbt](https://www.scala-sbt.org/index.html)
    3. [sbt-intro](https://zhuanlan.zhihu.com/p/82727108)
2. Install
    
    ```sh
    SBT_VERSION=1.5.4
    wget https://github.com/sbt/sbt/releases/download/v${SBT_VERSION}/sbt-${SBT_VERSION}.tgz
    ```
3. Envs

    ```sh
    export SBT_HOME=...
    export PATH=${SBT_HOME}/bin:${PATH}
    ```
4. Configurations
    1. `~/.sbt/repositories`

        ```ini
        [repositories]
        local
        huaweicloud-maven: https://repo.huaweicloud.com/repository/maven/
        maven-central: https://repo1.maven.org/maven2/
        sbt-plugin-repo: https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_ [sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]
        ```
    2. Settings
        1. Path
            1. windows: `${SBT_HOME}/conf/sbtconfig.txt` 
            2. Linux: `${SBT_HOME}/conf/sbtopts`
        2. Contents
            1. `-XX:MaxPermSize=256m`: `Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=256m; support was removed in 8.0`
            2. `-Dsbt.override.build.repos=true`: use global repo
5. File Structure
    1. `project_name/`
        1. `build.sbt`
            1. `name := "hello-world"`
            2. `version := "1.0"`
            3. `scalaVersion := "2.13.1"`
            4. `organization := "ch.epfl.scala"`
            5. `scalacOptions ++= Seq("-unchecked", "-deprecation")`
            6. `libraryDependencies += "org.typelevel" %% "cats-core" % "2.0.0"`: mananged jar dependencies
                1. format: `groupID % artifactID % revision % configuration`
                    1. `%%` instead of `%` after groupID will add scala version to the artifactID name
                    2. `% configuration`
                        1. `test`: just for sbt `test` command , not for `compile`, useful for test dependencies package
                2. stored path
                    1. windows: `%LOCALAPPDATA%\Coursier\Cache\v1`
                    2. Linux: `~/.cache/coursier/v1; ~/.ivy2/cache`
                    3. Mac: `~/Library/Caches/Coursier/v1`
            7. `resolvers += <name> at <location>`: specify additinal dependencies download path
                1. `resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"`
        2. `project/`
            1. `build.properties`
                1. `sbt.version=1.5.4`
                    1.  `intellij sbt: Extracting structure failed`: make sure `sbt.version` is correct
        3. `scr/`
            1. `main/`
                1. `scala/`
                2. `resources/`
            2. `test/`
                1. `scala/`
                2. `resources/`
        4. `target/`: build output, included in `.gitignore`
        5. `lib/`: unmanaged jar dependencies which automatically added to `classpath` compared to mananged dependencies
            1. `unmanagedBase := baseDirectory.value / "custom_lib"`: specify customized path
                1. `baseDirectory.value`: root directory
                2. `custom_lib`: customized path, `[default: lib]`
6. Commands
    1. `sbtVersion`
    2. `show overrideBuildResolvers`: `true` when `-Dsbt.override.build.repos=true`
    3. `show fullResolvers`: show `sbtconfig.txt` config
    4. `show compile:dependencyClasspath`
    5. `show test:dependencyClasspath`
    6. `help <command>`
    7. `reload`: reload build files, `build.sbt`, `project/{*.scala, *.sbt}`
    8. `clean`: clear output under `target/`
    9.  `update`: download dependencies manually, used by `compile`, so always no need to execute it
    10. `compile`: files in `src/main/{scala, java}`
    11. `test`: compile and run test file
    12. `console`: enter scala shell with compiled environment
    13. `run [arguments]`: run main class
    14. `package`: generate a jar file from `scr/main/resources` and `scr/main/{scala,java}`,  need `name` and `version` in the file `build.sbt`
    15. `~<command>`: run the command automatically when files update, `~run`. `Enter` key will cancel it

## Scala Language

1. References
    1. [shapeless-guide](https://books.underscore.io/shapeless-guide/shapeless-guide.html)
1. Command
    1. `scalac`
        1. `scalac helloworld.scala`: compiles scala source
        2. `scalac -d classes helloworld.scala`: compiles scala source, and stores in specified folder
    2. `fsc`: fast scala compiler
        1. `fsc helloworld.scala`
        2. `fsc -shutdown`: shutdown daemon process
    3. `jar`
        1. `jar cvf helloworld.jar -C classes/ .`: package classes into helloworld.jar under the current directory
        2. `jar tvf helloworld.jar`
    4. `scala`
        1. `scala helloworld.scala`: runs scala script
        2. `scala helloworld`: runs compiled scala file
        3. `scala helloworld.jar`
        4. `scala -cp helloworld.jar Hello`: runs Hello in jar file
2. Data Structure
    1. Architecture
        1. Relations
            1. `scala.Any`
                1. `scala.AnyVal`
                    1. `scala.Byte`
                    2. `scala.Short`
                    3. `scala.Int`
                    4. `scala.Long`
                    5. `scala.Float`
                    6. `scala.Double`
                    7. `scala.Char`
                    8. `scala.Boolean`
                    9. `scala.Unit`
                    10. ...
                2. `scala.AnyRef`
                    1. `scala.lang.String`
                    2. `scala.iterable`
                        1. `scala.Seq`
                            1. `scala.List`
                    3. `scala.Null`: subclass of all `scala.AnyRef` class
                3. `scala.Nothing`: subclass of all `scala.AnyRef` and `scala.AnyVal`
        2. Types
            1. immutable
                1. `java.lang.String`
                2. `[scala.]List(1, 2, 3)`
                3. `Tuple: (99, "buff")`: contain fixed-length and different types of elements, length up to 22 Tuple22
                4. `[scala.collection.immutable.]Set("Abuout", "Before")`
                5. `[scala.collection.immutable.]HashSet("Abuout", "Before")`
                6. `[scala.collection.immutable.]Map("A" -> "Abuout", "B" -> "Before")`
                7. `[scala.collection.immutable.]HashaMap("A" -> "Abuout", "B" -> "Before")`
                8. `[scala.collection.immutable.]Range`
            2. mutable
                1. `Array`
                2. `scala.collection.mutable.ListBuffer`
                3. `scala.collection.mutable.Set("About", "Before")`
                4. `scala.collection.mutable.HashSet("About", "Before")`
                5. `scala.collection.mutable.Map("A" -> "Abuout", "B" -> "Before")`
                6. `scala.collection.mutable.HashaMap("A" -> "Abuout", "B" -> "Before")`
            3. IO
                1. `scala.io.Source`
                2. `Console`
                3. `java.io.File`
    2. Primitive
        1. Numeric
            1. Interger
                1. Byte: 8 bits, `-2^7 ~ 2^7 -1`
                2. Short: 16bits, `-2^15 ~ 2^15 - 1`
                3. Int: 32 bits, `-2^31 ~ 2^31 - 1`
                4. Long: 64 bits, `-2^63 ~ 2^63 - 1`
            2. Float
                1. Float: 32 bits IEEE 754 single-precision float
                2. Double: 64 bits IEEE 754 single-precision float
            3. Literal
                1. `12`: int, base 10
                2. `0x5, 0xff`: int, base 16
                3. `12L`: long
                4. `1.0, 1.0e10, 1.0d 1.0D`: double
                5. `1.0f 1.0F`: float
            4. Methods
                1. `.to()`: `(0).to(3), 0 to 3`, include 0 and 3
                2. `0 unitl 3`: include 0, excluding 3
                3. `.toString()`
                4. `.toBinaryString()`
                5. `.numberOfTrailingZeros()`
                6. `.max(10)`
                7. `.min(10)`
                8. `.abs()`
        2. Char: 16 bits unsigned unicode character, `0 ~ 2^16 - 1`
            1. Literal
                1. `'A'`: unicode character between single quote ''
                2. `'\uxxxx'`: `x` is hex digit, '\u0041' '\u00fa'
            2. Escaping
                1. `'\b'`: backspace
                2. `'\t'`: tab
                3. `'\n'`: line feed
                4. `'\f'`: form feed
                5. `'\r'`: carrige return
                6. `'\"'`: double quote
                7. `'\''`: single quote
                8. `'\\'`: backslash
            3. Methods
                1. `.toByte()`
        3. Boolean: `[true, false]`
        4. Unit
            1. `()` value
            2. `Unit` returned when function returns no value
            3. `Unit == ""`: return `false`
    3. Complex
        1. Option
            1. value
                1. `Some(10), Some("hello")`
                2. `None`
            2. methods
                1. `.getOrElse("unknown")`
            
            ```scala
            optionValue match {
                case some(v) => println("hello" + v")
                case None => println("hello")
            }
            ```
        2. String
            1. Literal
                1. single quote: `"hello, world"`
                2. triple quotes

                    ```scala
                    """hello,
                        world!"""
                    =>
                    hello,
                        world!

                    """|hello,
                       |world!""".stripMargin
                    =>
                    hello,
                    world!
                    ```
            2. Methods
                1. `+`: concatenate strings
                2. `*`: concatenate string multiple times
                3.  `.length`
                4.  `.isEmpty`
                5. `.toLowerCase()`
                6. `.toUpperCase()`
                7. `.captalize()`
                8. `.[toByte, toShort, toInt, toLong, toFloat, toDouble]()`
                9. `.mkString()`
                10. `.substring()`
                11. `.split()`
                12. `.endsWith()`
                13. `.matches()`
                14. `.contains()`
                15. `.trim()`
                16. `.drop(2)`
                17. `.stripMargin()`
                18. `s"hello, $name, age is: ${6 * 7}"`: string interpolates
                19. `raw"no\\\\escape!" => no\\\\escape!`: raw string will not escape
                20. `f"${math.pi}%.5f"`: printf-style formatting, when no `"%"`, then default is "%s", the toString value
        3. List
            1. Literal
                1. `Nil`: same as `List()`, an emply list
            2. Methods
                1. `::`: prepend a new element to the beginning of an existing list and returns the new list
                2. `:::`: concatenas list
                3. `.length`: get the number of the elements
                4. `.isEmpty`: determine whether the list is empty
                5. `.head`: get the first element
                6. `.last`: get the last element
                7. `.init`: get all but the last element
                8. `.tail`: get all but the first element
                9. `.reverse` - gets a reversed list
                10. `.sorted` - gets a sorted list
                11. `.count(s => s.length == 4)`: get number of elements with length 4
                12. `.exists(s => s == "util")`: determin whether exists a `"util"` element
                13. `.contains("util")`
                14. `.forall(s => s.endsWith("l"))`: determin whether all elements ends with "l"
                15. `.mkString(",")`: makes a string using giving delemiter
                16. `.map(s => s + "y")`
                17. `.foreach(s => println(s)) <=> .foreach(println)`: execute on each elements
                18. `.filter(s => s.length == 4)`
                19. `.filterNot(s => s.length == 4)`: get the opposite elements of `.filter()`
                20. `.reduceLeft((a, b) => if (a.length > b.length) a else b`
                21. `.sortWith((s, t) => s.charAt(0).toLower < t.charAt(0).toLower)`: get list ordered by the first lowered char
                22. `.drop(2)`: drop the first 2 elements
                23. `.dropRight(2)`: drop the rightmost 2 elements
            
            ```scala
            val oneTwo = List(1, 2)
            val threeFour = List(3, 4)
            oneTwo ::: threeFour
            1 :: oneTwo <=> oneTwo.::(1)
            val ontTwoThree = 1 :: 2 :: 3 :: Nil
            ```
        4. Array
            1. Property
                1. Arrays are mutable, but fixed-length
                2. when using new Array, 0 for numeric array, false for Boolean, null for String, and other types
            2. Initialization
                1. `new Array[T](length)`
                2. `Array(1, 3, 5)`
                3. `Array("hello", "world")`
        5. LIstBuffer
            1. Methods
                1. `.toList`
        6. Tuple
            1. Literal
                1. `val pair = (99, "buffer")`: initialize using `()`
                2. `pair._2`: accesse individual with ._N, N starts with 1, up to 22
                3. `.productIterator`
        7. Set & Map
            1. Methods
                1. `+=`: append a item, not apply for immutable
                2. `.contains("A')`
            
            ```scala
            val x = new HashMap[Int, String]()
            var direct = Map("A" -> "About", "B" -> "Before")
            direct += ("C" -> "Center")
            direct("C")
            ```
        8. Range
            1. Methods
                1. `0 to 3`
                2. `0 until 3`
        9.  Source
            1. Methods
                1. `Source.fromFile("hello.txt")`: read file from normal path
                2. `Source.fromResource("hello.txt").getLines`: read file from `resources` folder, `scalaVersion >= 2.13`
        10. Console
            1. `Console.print()`
            2. `Console.println()`: end with a linefeed
            3. `Console.out.println()`
            4. `Console.err.println()`
        11. File
            1. `.listFiles()`
            2. `.getName()`
3. Syntax
    1. Base
        1. `[// ...,  /* ... */]`: comments
        2. `Summer.scala`: scala file name follows the class or object name
    2. Identifiers
        1. start with a letter or underscore, then letters, digits, or underscore
        2. `$` also counts as a letter, reserved for compiler which should be avoided to use
        3. avoid identifiers like `__init__` or `name_` for underscore has other non-identifiers usage in scala
        4. use camel-case style, e.g., `toString`
        5. constant names also follow camel-case, with the first character upper case, such as `XOffset`
        6. followings should start with a lower case letter
            1. variable
            2. field
            3. method parameter
            4. function
        7. following should start with an upper case letter
            1. class
            2. trait
    3. Variable
        1. `val`: initialized once, cannot be reassigned, similar to a final variable in Java
        2. `var`: can be reassigned
        3. same name variable can not be defined in the same scope, different scope can define same name
    4. Operator
        1. Infix Operator
            1. infix operator invokes method to sit between the object and the parameter
            2. when the method takes multiple arguments, the arguments should be placed in parentheses `()`

            ```scala
            val s = "hello, world"
            s indexOf 'o' <=> s.indexOf('o')
            s indexOf ("o", 5) <=> s.indexOf("o", 5)
            ```
        2. Prefix Operator: only the following four identifiers can be prefix operator
            1. `+`
            2. `-`
            3. `!`
            4. `~`

            ```scala
            -2.0 <=> (2.0).unary_-
            !a <=> a.unary_!
            ~1 <=> 1.unary_~
            ```
        3. Postfix Operator
            1. postfix operators takes no arguments, which can be invoked without a dot or parentheses
            2. if the method has side effects, the convention is to include parentheses, such as `.print()`

            ```scala
            val s = "hello, world"
            s toLowerCase <=> s.toLowerCase
            ```
        4. Arithmetic Operator
            1. `+ - * / %`
            2. `+ -`: positive and negative sign
        5. Relational Operator 
            1. `> < >= <= != ==`
            2. `this == that <=> if (this eq null) that eq null else this.equals(that)`: compares contents
            3. `this eq that, this ne that`: determine whether this and that beging the same object reference
            4. `null == null && null eq null <=> true`
        6. Logical Operator
            1. `&&, ||`: short-circuit
            2. `&, |`: all will be evaluated
            3. `!`: invert a boolean value
        7. Bitwise Operator
            1. `& | ^ ~`
            2. `<<, >>`: signed left and right shift
            3. `>>>`: unsigned right shift
            4. `<<, >>>`: fill with zeroes
            5. `>>`: fill with the highest sign bit of the left-hand value
        8. Assignment Operator
            1. `= += -+ *= /= %=`
        9. Operator Precedence
            1. Property
                1. precedence is based on the first character of the methods used in operator notation
                2. if the operator ends with `=`, and the operator is not in `<=, >=, ==, !=`, then the precedence is same as `=`
            2. Order
                1. all other special characters
                2. `+ / %`
                3. `+ -`
                4. `:`
                5. `== !=`
                6. `< >`
                7. `&`
                8. `^`
                9. `|`
                10. all letters
                11. all assignment operators
            3. Examples
                1. `2 << 2 + 2 <=> 2 << (2 + 2)`: the starting `<` is lower than `+`
                2. `x *= y + 1 <=> x *= (y + 1)`: `*=` precedence is same as `=`
        10. Operator Associativity
            1. the associativity is based on the last character `:`
            2. any operator ending with a `:` is invoked on its right operand, passing in the left operand
            3. methods ending with other character are invoked on their left operand, passing in the right operand

            ```scala
            a * b <=> a.*(b)
            a ::: b <=> b.:::(a)
            ```
4. Control Structure
    1. Conditonal
        1. If
            1. `if (boolean) {...}`: `if` returns a value
            2. `if (boolean) {...} else if {...} else {...}`
        2. Match
            1. return a value, which can be stored in a variable
            2. any kind of constant can be used, not just integer-type, enum and string contants in Java's case statements
            3. no break at the end of each case. it is implicit, therefore there is no fall through from one to the next
            4. `_` for unknown value
        
        ```scala
        val firstArg = if (args.length > 0) args(0) else ""    
        firstArg match {
            case "salt" => println("pepper")
            case "chips" => println("salsa")
            case "eggs" => println("bacon")
            case _ => println("huh?")
        }
        
        val firstArg = if (!args.isEmpty) args(0) else ""
        val friend = firstArg match {
                case "salt" => "pepper"
                case "chips" => "salsa"
                case "eggs" => "bacon"
                case _ => "huh?"
        }           
        println(friend)
        ```
    2. Looping
        1. while: return a `Unit` value
            1. `while (boolean) {...}`
            2. `do {...} while (boolean)`
        2. for
            1. `for (arg <- args) {...}`: arg is a val type generated in each iteration;  `<-` means `in`
            2. `for (arg <- args if arg % 2 == 0) {...}`: with `if` filter
            3. `for (arg <- args; brg <- brgs) {...}`: multiple `<-`
            4. `for (...) yield {...}`: `yield` collects values in each iteration
        3. Notes
            1. scala leaves out break and continue command, they do not mesh well with function literals
            2. the simplest approach is to replace every continue by an if and every break by a boolean variable

            ```scala
            // use ()
            for (
                file <- filesHere
                if file.getName.endsWith(".scala");
                line <- fileLines(file)
                if line.trim.matches(pattern) 
                ) println(file + ": " + line.trim)

            // use {}, for multiple line ";" can be omitted
            for {
                 file <- filesHere
                    if file.getName.endsWith(".scala")
                    line <- fileLines(file)
                    trimmed = line.trim
                    if trimmed.matches(pattern)  
                } println(file + ": " + trimmed)

            // use yield 
            val forLineLengths =
                for {
                    file <- filesHere
                    if file.getName.endsWith(".scala")
                    line <- fileLines(file)
                    trimmed = line.trim
                    if trimmed.matches(".*for.*")  
                } yield trimmed.length

            // java use break and continue
            int i = 0;
            boolean foundIt = false;
            while (i < args.length) {
                if (args[i].startsWith("-")) {
                  i = i + 1;
                  continue;
                }
                if (args[i].endsWith(".scala")) {
                  foundIt = true;
                  break;
                }
                i = i + 1;
            }

            // scala use var variables
            var i = 0
            var foundIt = false
            while (i < args.length && !foundIt) {
                if (!args(i).startsWith("-")) {
                    if (args(i).endsWith(".scala"))
                        foundIt = true
                }
                i = i + 1
            }

            // scala use a recursive function, without var variables
            def searchFrom(i: Int): Int =
                if (i >= args.length) -1
                 else if (args(i).startsWith("-")) searchFrom(i + 1) 
                 else if (args(i).endsWith(".scala")) i
                 else searchFrom(i + 1)
            val i = searchFrom(0)
            ```
5. Function
    1. Properties
        1. parameters are val type
        2. `return` at the end of function can be omitted, then the last value is returned
        3. a function's side effect is generally defined as mutating state external to the method or performing io action
        4. a functional style prefers vals, immutable objects, and methods without side effects
        5. use vars, mutable objects, and methods with side effects when you have a specific need and justification for them
    2. Literal
        1. `(x: Int, y: Int) => x + y`: specify parameter type
        2. `someNumbers.filter(x => x > 0)`: without parameter type
        3. `someNumbers.filter(_ > 0)`: `_` is placeholder for parameter syntax, when each parameter appears only once
        4. `someNumbers.foreach(println _) <=> someNumbers.foreach(x => println(x))`: placeholder for an entire parameter list, not just a single parameter, require a space between function name and `_`
        5. `someNumbers.foreach(println _) <=> someNumbers.foreach(println)`: `_` can be omitted when a function is invoked as a method reference, otherwise causes an error
    3. Definition
        1. regular

            ```scala
            def max(x: Int, y: Int): Int = {
                if (x > y) x
                else y
            }
            ```
        2. with repeated parameters

            ```scala
            def echo(args: String*) = {}
            echo(arr: _*)
            ```
        3. with named arguments

            ```scala
            def speed(distance: Float, time: Float): Float = distance / time
            speed(distance = 100, time = 10)
            ```
        4. with default parameter values

            ```scala
            def printTime(out: java.io.PrintStream = Console.out) =
                out.println("time = " + System.currentTimeMillis())
            ```
        5. multiple parameter lists

            ```scala
            def myLoop(start: Int, end: Int) (callback: Int => Unit) = {
                for (i <- Range(start, end)) {
                    callback(i)
                }
            }

            myLoop(start = 5, end = 10) { i => println(s"i has value ${i}")}
            ```
6. Class
    1. Initialization
        1. New
            1. `val big = new java.math.BigInteger("12345")`: parameterize with value
            2. `val greetStrings = new Array[String](3)`: parameterize with type and length
        2. Factory Method
            1. Properties
                1. a factory method calls an `apply` method, which creates and returns the new object
                2. the `apply` method is defined on the corresponding companion class which seems like calling a static method from the class
            2. Examples
                1. `arr(2) <=> arr.apply(2)`: a variable surrounded by `()` invocates an `apply` method on that variable
                2. `val greetStrings = Array("zero", "one", "two") <=> Apply.apply("zero", "one", "two")`
                3. `arr(2) =  "hello" <=> arr.update(2, "hello")`: an assignment invocates an update method
                4. `1 -> "Go" <=> (1).->("Go")`: `->` can be invoked on any object, returns a two-element tuple, see Map
    2. Modifiers
        1. `public`: default, no need to specify
        2. `private`
        3. `protected`: only accesible for subclasses of the class in which the member is defined
        4. `override`
        5. `require`: `require(d != 0)` defined in standalone object `Predef`
        6. `this`: self reference
        7. `this(n: Int) = this(n, 1)`: auxiliary constructor must invoke another constructor of the same class first. the primary construction is the final single point of entry of a class, and the only calls supclass constructor
    3. Definition
        1. Regular

            ```scala
            class ChecksumAccumulator {
                private var sum = 0
                def add(b: Byte): Unit = { sum += b }
                def checusum(): Int = ~(sum & 0xff) + 1
            }

            class Rational(n: Int, d: Int) {
                require(d != 0)
                val numer: Int = n
                val denom: Int = d

                def this(n: Int) = this(n, 1) // auxiliary constructor

                override def toString = numer + "/" + denom

                def add(that: Rational): Rational =
                    new Rational(
                      numer * that.denom + that.numer * denom,
                      denom * that.denom
                    )

                def + (that: Rational): Rational =
                    new Rational(
                      numer * that.denom + that.numer * denom,
                      denom * that.denom
                    )

                def lessThan(that: Rational) = 
                    this.numer * that.denom < that.numer * this.denom

                def max(that: Rational) = 
                    if (this.lessThan(that)) that else this
            }
            ```
        2. singleton object
            1. a singleton function behavies like a static method in Java
            2. share same name with a class, it is called that class's companion object. 
            3. the class is called the companion class of the singleton. they are defined in the same source file.
            4. the class and the singleton can access each other's private members
            5. a singleton wihout a companion class is a standalone object. it can collect utility methods or become an app's entry point
            6. the entry point has a `main` method, takes an `Array[String]` parameter and returns a `Unit` value, e.g.,

                ```scala
                import ChecksumAccumulator.calculate
  
                object Summer {
                    def main(args: Array[String]): Unit = {
                        for (arg <- args)
                            println(arg + ": " + calculate(arg))
                        }
                }
                ```
            
            ```scala
            import scala.collection.mutable
  
            object ChecksumAccumulator {
                private val cache = mutable.Map.empty[String, Int]

                def calculate(s: String): Int = 
                    if (cache.contains(s))
                        cache(s)
                    else {
                        val acc = new ChecksumAccumulator
                        for (c <- s)
                            acc.add(c.toByte)
                        val cs = acc.checksum()
                        cache += (s -> cs)
                        cs
                      }
            }

            val ca = ChecksumAccumulator.calculate("Every value is an object.")
            ```
        3. Case Class
            1. Properties
                1. automatically create a singleton object, which has following methods and traits
                    1. Methods
                        1. `apply())`
                        2. `unapply()`: for pattern match
                        3. `copy()`: `val b = a.copy()`
                        4. `toString()`
                        5. `hashCode()`
                        6. `equals()`: instances are compared by structure and not by reference
                    2. Inherited Traits
                        1. `Product`
                        2. `Serializable`
                2. suitable for immutable data, parameters are public val types
            2. Definitions

                ```scala
                case class Person(name: String, age: Int)
                ```
        4. Case Object:
            1. Properties
                1. similar to case class, but without `apply()` and `unapply()` methods
                2. use when no parameters are needed 
        5. `scala.APP` Trait
            1. work like a singleton object with a `main` method, use `args` to access command-line arguments

            ```scala
            import ChecksumAccumulator.calculate
  
            object FallWinterSpringSummer extends App {
                for (season <- List("fall", "winter", "spring"))
                    println(season + ": " + calculate(season))
            }
            ```
7. Exception
    1. `throw new IllegalArgumentException`: `throw` has type `Nothing`
    2. `try{} catch{} finally {}`: returns a value, if exception thrown not caught, the expression has no result at all
    3. the value computed in the `finally` clause, if there is one, is dropped, it usually does some clean work
    4. if `finally` has explicit return, or throws an exception, the return value or exception will the final expression result

        ```scala
        def f(): Int = try return 1 finally return 2 => f() => 2
        def g(): Int = try 1 finally 2 // g() => 1
        ```

    ```scala
    def urlFor(path: String) =
        try {
            new URL(path)
        } catch {
            case e: MalformedURLException =>
            new URL("http://www.scala-lang.org")
        }
    
    try {
        val file = new FileReader("input.txt")
        ...
    } catch {
        case ex: IOException => // Handle I/O error
        case ex: OtherException => // Handle other condition
    } finally {
        file.close()
    }
    ```
8. Package
    1. Implicit Imports
        1. `java.lang`
        2. `scala`
        3. `Predef`
            1. `println` invokes `Predef.println`, which invokes `Console.println`
            2. `assert` invokes `Predef.assert`
    2. Import: allow using a simple package element name
        1. `import org.apache.spark.sql.SparkSession`
        2. `import org.apache.spark.sql.{SparkSession, Row, SaveMode}`

        ```scala
        import scala.collection.mutable
        var helloSet = mutable.Set("hello", "world")
        ```
9. Common Class
    1. `System`
        1. `System.exit(<n>)`
        2. `System.err.println()`
    2. `java.io.File`
        1. Methods
            1. `getAbsolutePath()`
    3. `java.util.Properties`
